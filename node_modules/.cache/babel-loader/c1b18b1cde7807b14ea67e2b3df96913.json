{"ast":null,"code":"/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, Messages, Regex, source, strict, index, lineNumber, lineStart, hasLineTerminator, lastIndex, lastLineNumber, lastLineStart, startIndex, startLineNumber, startLineStart, scanning, length, lookahead, state, extra, isBindingElement, isAssignmentTarget, firstCoverInitializedNameError;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9,\n    Template: 10\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n  TokenName[Token.Template] = 'Template'; // A function following one of those tokens is an expression.\n\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExportAllDeclaration: 'ExportAllDeclaration',\n    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n    ExportNamedDeclaration: 'ExportNamedDeclaration',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForOfStatement: 'ForOfStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MetaProperty: 'MetaProperty',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    RestElement: 'RestElement',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    Super: 'Super',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    YieldExpression: 'YieldExpression'\n  };\n  PlaceHolders = {\n    ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n  }; // Error messages should be identical to V8.\n\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n    DefaultRestParameter: 'Unexpected token =',\n    ObjectPatternAsRestParameter: 'Unexpected token {',\n    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n    DuplicateConstructor: 'A class may only have one constructor',\n    StaticPrototype: 'Classes may not have static property named prototype',\n    MissingFromClause: 'Unexpected token',\n    NoAsAfterImportNamespace: 'Unexpected token',\n    InvalidModuleSpecifier: 'Unexpected token',\n    IllegalImportDeclaration: 'Unexpected token',\n    IllegalExportDeclaration: 'Unexpected token',\n    DuplicateBinding: 'Duplicate binding %0'\n  }; // See also tools/generate-unicode-regex.js.\n\n  Regex = {\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n  }; // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 && ch <= 0x39; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n\n  function octalToDecimal(ch) {\n    // \\0 is not octal escape sequence\n    var octal = ch !== '0',\n        code = '01234567'.indexOf(ch);\n\n    if (index < length && isOctalDigit(source[index])) {\n      octal = true;\n      code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n      // with 0, 1, 2, 3\n\n      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n        code = code * 8 + '01234567'.indexOf(source[index++]);\n      }\n    }\n\n    return {\n      code: code,\n      octal: octal\n    };\n  } // ECMA-262 11.2 White Space\n\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  } // ECMA-262 11.3 Line Terminators\n\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  } // ECMA-262 11.6 Identifier Names and Identifiers\n\n\n  function fromCodePoint(cp) {\n    return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));\n  }\n\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch >= 0x30 && ch <= 0x39 || // 0..9\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n  } // ECMA-262 11.6.2.2 Future Reserved Words\n\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'enum':\n      case 'export':\n      case 'import':\n      case 'super':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  } // ECMA-262 11.6.2.1 Keywords\n\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n\n      case 10:\n        return id === 'instanceof';\n\n      default:\n        return false;\n    }\n  } // ECMA-262 11.4 Comments\n\n\n  function addComment(type, value, start, end, loc) {\n    var comment;\n    assert(typeof start === 'number', 'Comment must have valid position');\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n\n    extra.comments.push(comment);\n\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n\n    if (extra.tokenize) {\n      comment.type = comment.type + 'Comment';\n\n      if (extra.delegate) {\n        comment = extra.delegate(comment);\n      }\n\n      extra.tokens.push(comment);\n    }\n  }\n\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n\n      if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n\n        hasLineTerminator = true;\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n\n          return;\n        }\n\n        ++index;\n      } else {\n        ++index;\n      }\n    } // Ran off the end of the file - the whole thing is a comment\n\n\n    if (extra.comments) {\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      comment = source.slice(start + 2, index);\n      addComment('Block', comment, start, index, loc);\n    }\n\n    tolerateUnexpectedToken();\n  }\n\n  function skipComment() {\n    var ch, start;\n    hasLineTerminator = false;\n    start = index === 0;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        ++index;\n\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n\n          ++index; // `!`\n\n          ++index; // `-`\n\n          ++index; // `-`\n\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n    var ch, code;\n    ch = source[index];\n    code = 0; // At least, one hex digit is required.\n\n    if (ch === '}') {\n      throwUnexpectedToken();\n    }\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (!isHexDigit(ch)) {\n        break;\n      }\n\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    }\n\n    if (code > 0x10FFFF || ch !== '}') {\n      throwUnexpectedToken();\n    }\n\n    return fromCodePoint(code);\n  }\n\n  function codePointAt(i) {\n    var cp, first, second;\n    cp = source.charCodeAt(i);\n\n    if (cp >= 0xD800 && cp <= 0xDBFF) {\n      second = source.charCodeAt(i + 1);\n\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        first = cp;\n        cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n\n    return cp;\n  }\n\n  function getComplexIdentifier() {\n    var cp, ch, id;\n    cp = codePointAt(index);\n    id = fromCodePoint(cp);\n    index += id.length; // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n    if (cp === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwUnexpectedToken();\n      }\n\n      ++index;\n\n      if (source[index] === '{') {\n        ++index;\n        ch = scanUnicodeCodePointEscape();\n      } else {\n        ch = scanHexEscape('u');\n        cp = ch.charCodeAt(0);\n\n        if (!ch || ch === '\\\\' || !isIdentifierStart(cp)) {\n          throwUnexpectedToken();\n        }\n      }\n\n      id = ch;\n    }\n\n    while (index < length) {\n      cp = codePointAt(index);\n\n      if (!isIdentifierPart(cp)) {\n        break;\n      }\n\n      ch = fromCodePoint(cp);\n      id += ch;\n      index += ch.length; // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n      if (cp === 0x5C) {\n        id = id.substr(0, id.length - 1);\n\n        if (source.charCodeAt(index) !== 0x75) {\n          throwUnexpectedToken();\n        }\n\n        ++index;\n\n        if (source[index] === '{') {\n          ++index;\n          ch = scanUnicodeCodePointEscape();\n        } else {\n          ch = scanHexEscape('u');\n          cp = ch.charCodeAt(0);\n\n          if (!ch || ch === '\\\\' || !isIdentifierPart(cp)) {\n            throwUnexpectedToken();\n          }\n        }\n\n        id += ch;\n      }\n    }\n\n    return id;\n  }\n\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getComplexIdentifier();\n      } else if (ch >= 0xD800 && ch < 0xDFFF) {\n        // Need to handle surrogate pairs.\n        index = start;\n        return getComplexIdentifier();\n      }\n\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n\n    return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n    var start, id, type;\n    start = index; // Backslash (U+005C) starts an escaped character.\n\n    id = source.charCodeAt(index) === 0x5C ? getComplexIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.7 Punctuators\n\n\n  function scanPunctuator() {\n    var token, str;\n    token = {\n      type: Token.Punctuator,\n      value: '',\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: index,\n      end: index\n    }; // Check for most common single-character punctuators.\n\n    str = source[index];\n\n    switch (str) {\n      case '(':\n        if (extra.tokenize) {\n          extra.openParenToken = extra.tokenValues.length;\n        }\n\n        ++index;\n        break;\n\n      case '{':\n        if (extra.tokenize) {\n          extra.openCurlyToken = extra.tokenValues.length;\n        }\n\n        state.curlyStack.push('{');\n        ++index;\n        break;\n\n      case '.':\n        ++index;\n\n        if (source[index] === '.' && source[index + 1] === '.') {\n          // Spread operator: ...\n          index += 2;\n          str = '...';\n        }\n\n        break;\n\n      case '}':\n        ++index;\n        state.curlyStack.pop();\n        break;\n\n      case ')':\n      case ';':\n      case ',':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        ++index;\n        break;\n\n      default:\n        // 4-character punctuator.\n        str = source.substr(index, 4);\n\n        if (str === '>>>=') {\n          index += 4;\n        } else {\n          // 3-character punctuators.\n          str = str.substr(0, 3);\n\n          if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=') {\n            index += 3;\n          } else {\n            // 2-character punctuators.\n            str = str.substr(0, 2);\n\n            if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>') {\n              index += 2;\n            } else {\n              // 1-character punctuators.\n              str = source[index];\n\n              if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                ++index;\n              }\n            }\n          }\n        }\n\n    }\n\n    if (index === token.start) {\n      throwUnexpectedToken();\n    }\n\n    token.end = index;\n    token.value = str;\n    return token;\n  } // ECMA-262 11.8.3 Numeric Literals\n\n\n  function scanHexLiteral(start) {\n    var number = '';\n\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (number.length === 0) {\n      throwUnexpectedToken();\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function scanBinaryLiteral(start) {\n    var ch, number;\n    number = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (number.length === 0) {\n      // only 0b or 0B\n      throwUnexpectedToken();\n    }\n\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      /* istanbul ignore else */\n\n      if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n        throwUnexpectedToken();\n      }\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 2),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function scanOctalLiteral(prefix, start) {\n    var number, octal;\n\n    if (isOctalDigit(prefix)) {\n      octal = true;\n      number = '0' + source[index++];\n    } else {\n      octal = false;\n      ++index;\n      number = '';\n    }\n\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (!octal && number.length === 0) {\n      // only 0o or 0O\n      throwUnexpectedToken();\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function isImplicitOctalLiteral() {\n    var i, ch; // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index]; // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      // Octal number in ES6 starts with '0o'.\n      // Binary number in ES6 starts with '0b'.\n\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n\n        if (ch === 'b' || ch === 'B') {\n          ++index;\n          return scanBinaryLiteral(start);\n        }\n\n        if (ch === 'o' || ch === 'O') {\n          return scanOctalLiteral(ch, start);\n        }\n\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(ch, start);\n          }\n        }\n      }\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === '.') {\n      number += source[index++];\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwUnexpectedToken();\n      }\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.4 String Literals\n\n\n  function scanStringLiteral() {\n    var str = '',\n        quote,\n        start,\n        ch,\n        unescaped,\n        octToDec,\n        octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                str += scanUnicodeCodePointEscape();\n              } else {\n                unescaped = scanHexEscape(ch);\n\n                if (!unescaped) {\n                  throw throwUnexpectedToken();\n                }\n\n                str += unescaped;\n              }\n\n              break;\n\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            case '8':\n            case '9':\n              str += ch;\n              tolerateUnexpectedToken();\n              break;\n\n            default:\n              if (isOctalDigit(ch)) {\n                octToDec = octalToDecimal(ch);\n                octal = octToDec.octal || octal;\n                str += String.fromCharCode(octToDec.code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      index = start;\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: startLineNumber,\n      lineStart: startLineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.6 Template Literal Lexical Components\n\n\n  function scanTemplate() {\n    var cooked = '',\n        ch,\n        start,\n        rawOffset,\n        terminated,\n        head,\n        tail,\n        restore,\n        unescaped;\n    terminated = false;\n    tail = false;\n    start = index;\n    head = source[index] === '`';\n    rawOffset = 2;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === '`') {\n        rawOffset = 1;\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === '$') {\n        if (source[index] === '{') {\n          state.curlyStack.push('${');\n          ++index;\n          terminated = true;\n          break;\n        }\n\n        cooked += ch;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              cooked += '\\n';\n              break;\n\n            case 'r':\n              cooked += '\\r';\n              break;\n\n            case 't':\n              cooked += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                cooked += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n\n                if (unescaped) {\n                  cooked += unescaped;\n                } else {\n                  index = restore;\n                  cooked += ch;\n                }\n              }\n\n              break;\n\n            case 'b':\n              cooked += '\\b';\n              break;\n\n            case 'f':\n              cooked += '\\f';\n              break;\n\n            case 'v':\n              cooked += '\\v';\n              break;\n\n            default:\n              if (ch === '0') {\n                if (isDecimalDigit(source.charCodeAt(index))) {\n                  // Illegal: \\01 \\02 and so on\n                  throwError(Messages.TemplateOctalLiteral);\n                }\n\n                cooked += '\\0';\n              } else if (isOctalDigit(ch)) {\n                // Illegal: \\1 \\2\n                throwError(Messages.TemplateOctalLiteral);\n              } else {\n                cooked += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        ++lineNumber;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        lineStart = index;\n        cooked += '\\n';\n      } else {\n        cooked += ch;\n      }\n    }\n\n    if (!terminated) {\n      throwUnexpectedToken();\n    }\n\n    if (!head) {\n      state.curlyStack.pop();\n    }\n\n    return {\n      type: Token.Template,\n      value: {\n        cooked: cooked,\n        raw: source.slice(start + 1, index - rawOffset)\n      },\n      head: head,\n      tail: tail,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.5 Regular Expression Literals\n\n\n  function testRegExp(pattern, flags) {\n    // The BMP character to use as a replacement for astral symbols when\n    // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n    // approximation.\n    // Note: replacing with '\\uFFFF' enables false positives in unlikely\n    // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n    // pattern that would not be detected by this substitution.\n    var astralSubstitute = \"\\uFFFF\",\n        tmp = pattern;\n\n    if (flags.indexOf('u') >= 0) {\n      tmp = tmp // Replace every Unicode escape sequence with the equivalent\n      // BMP character or a constant ASCII code point in the case of\n      // astral symbols. (See the above note on `astralSubstitute`\n      // for more information.)\n      .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n        var codePoint = parseInt($1 || $2, 16);\n\n        if (codePoint > 0x10FFFF) {\n          throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        if (codePoint <= 0xFFFF) {\n          return String.fromCharCode(codePoint);\n        }\n\n        return astralSubstitute;\n      }) // Replace each paired surrogate with a single ASCII symbol to\n      // avoid throwing on regular expressions that are only valid in\n      // combination with the \"u\" flag.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);\n    } // First, detect invalid regular expressions.\n\n\n    try {\n      RegExp(tmp);\n    } catch (e) {\n      throwUnexpectedToken(null, Messages.InvalidRegExp);\n    } // Return a regular expression object for this pattern-flag pair, or\n    // `null` in case the current environment doesn't support the flags it\n    // uses.\n\n\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      /* istanbul ignore next */\n      return null;\n    }\n  }\n\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n\n      if (ch === '\\\\') {\n        ch = source[index++]; // ECMA-262 7.8.5\n\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n\n    if (!terminated) {\n      throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n    } // Exclude leading and trailing slash.\n\n\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n\n      ++index;\n\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n\n          if (ch) {\n            flags += ch;\n\n            for (str += \"\\\\u\"; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += \"\\\\u\";\n          }\n\n          tolerateUnexpectedToken();\n        } else {\n          str += '\\\\';\n          tolerateUnexpectedToken();\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n\n  function scanRegExp() {\n    var start, body, flags, value;\n    scanning = true;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    scanning = false;\n\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        regex: {\n          pattern: body.value,\n          flags: flags.value\n        },\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      regex: {\n        pattern: body.value,\n        flags: flags.value\n      },\n      start: start,\n      end: index\n    };\n  }\n\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    /* istanbul ignore next */\n\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        regex: regex.regex,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n\n    return regex;\n  }\n\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  } // Using the following algorithm:\n  // https://github.com/mozilla/sweet.js/wiki/design\n\n\n  function advanceSlash() {\n    var regex, previous, check;\n\n    function testKeyword(value) {\n      return value && value.length > 1 && value[0] >= 'a' && value[0] <= 'z';\n    }\n\n    previous = extra.tokenValues[extra.tokenValues.length - 1];\n    regex = previous !== null;\n\n    switch (previous) {\n      case 'this':\n      case ']':\n        regex = false;\n        break;\n\n      case ')':\n        check = extra.tokenValues[extra.openParenToken - 1];\n        regex = check === 'if' || check === 'while' || check === 'for' || check === 'with';\n        break;\n\n      case '}':\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        regex = false;\n\n        if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {\n          // Anonymous function, e.g. function(){} /42\n          check = extra.tokenValues[extra.openCurlyToken - 4];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : false;\n        } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {\n          // Named function, e.g. function f(){} /42/\n          check = extra.tokenValues[extra.openCurlyToken - 5];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : true;\n        }\n\n    }\n\n    return regex ? collectRegex() : scanPunctuator();\n  }\n\n  function advance() {\n    var cp, token;\n\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n\n    cp = source.charCodeAt(index);\n\n    if (isIdentifierStart(cp)) {\n      token = scanIdentifier();\n\n      if (strict && isStrictModeReservedWord(token.value)) {\n        token.type = Token.Keyword;\n      }\n\n      return token;\n    } // Very common: ( and ) and ;\n\n\n    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n      return scanPunctuator();\n    } // String literal starts with single quote (U+0027) or double quote (U+0022).\n\n\n    if (cp === 0x27 || cp === 0x22) {\n      return scanStringLiteral();\n    } // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n\n\n    if (cp === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n\n      return scanPunctuator();\n    }\n\n    if (isDecimalDigit(cp)) {\n      return scanNumericLiteral();\n    } // Slash (/) U+002F can also start a regex.\n\n\n    if (extra.tokenize && cp === 0x2F) {\n      return advanceSlash();\n    } // Template literals start with ` (U+0060) for template head\n    // or } (U+007D) for template middle or template tail.\n\n\n    if (cp === 0x60 || cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${') {\n      return scanTemplate();\n    } // Possible identifier start in a surrogate pair.\n\n\n    if (cp >= 0xD800 && cp < 0xDFFF) {\n      cp = codePointAt(index);\n\n      if (isIdentifierStart(cp)) {\n        return scanIdentifier();\n      }\n    }\n\n    return scanPunctuator();\n  }\n\n  function collectToken() {\n    var loc, token, value, entry;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      entry = {\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      };\n\n      if (token.regex) {\n        entry.regex = {\n          pattern: token.regex.pattern,\n          flags: token.regex.flags\n        };\n      }\n\n      if (extra.tokenValues) {\n        extra.tokenValues.push(entry.type === 'Punctuator' || entry.type === 'Keyword' ? entry.value : null);\n      }\n\n      if (extra.tokenize) {\n        if (!extra.range) {\n          delete entry.range;\n        }\n\n        if (!extra.loc) {\n          delete entry.loc;\n        }\n\n        if (extra.delegate) {\n          entry = extra.delegate(entry);\n        }\n      }\n\n      extra.tokens.push(entry);\n    }\n\n    return token;\n  }\n\n  function lex() {\n    var token;\n    scanning = true;\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    skipComment();\n    token = lookahead;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n    return token;\n  }\n\n  function peek() {\n    scanning = true;\n    skipComment();\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n  }\n\n  function Position() {\n    this.line = startLineNumber;\n    this.column = startIndex - startLineStart;\n  }\n\n  function SourceLocation() {\n    this.start = new Position();\n    this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n    this.start = {\n      line: startToken.lineNumber,\n      column: startToken.start - startToken.lineStart\n    };\n    this.end = null;\n  }\n\n  function Node() {\n    if (extra.range) {\n      this.range = [startIndex, 0];\n    }\n\n    if (extra.loc) {\n      this.loc = new SourceLocation();\n    }\n  }\n\n  function WrappingNode(startToken) {\n    if (extra.range) {\n      this.range = [startToken.start, 0];\n    }\n\n    if (extra.loc) {\n      this.loc = new WrappingSourceLocation(startToken);\n    }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n    processComment: function processComment() {\n      var lastChild,\n          innerComments,\n          leadingComments,\n          trailingComments,\n          bottomRight = extra.bottomRightStack,\n          i,\n          comment,\n          last = bottomRight[bottomRight.length - 1];\n\n      if (this.type === Syntax.Program) {\n        if (this.body.length > 0) {\n          return;\n        }\n      }\n      /**\n       * patch innnerComments for properties empty block\n       * `function a() {/** comments **\\/}`\n       */\n\n\n      if (this.type === Syntax.BlockStatement && this.body.length === 0) {\n        innerComments = [];\n\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n\n          if (this.range[1] >= comment.range[1]) {\n            innerComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n\n        if (innerComments.length) {\n          this.innerComments = innerComments; //bottomRight.push(this);\n\n          return;\n        }\n      }\n\n      if (extra.trailingComments.length > 0) {\n        trailingComments = [];\n\n        for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n          comment = extra.trailingComments[i];\n\n          if (comment.range[0] >= this.range[1]) {\n            trailingComments.unshift(comment);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n\n        extra.trailingComments = [];\n      } else {\n        if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n          trailingComments = last.trailingComments;\n          delete last.trailingComments;\n        }\n      } // Eating the stack.\n\n\n      while (last && last.range[0] >= this.range[0]) {\n        lastChild = bottomRight.pop();\n        last = bottomRight[bottomRight.length - 1];\n      }\n\n      if (lastChild) {\n        if (lastChild.leadingComments) {\n          leadingComments = [];\n\n          for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n            comment = lastChild.leadingComments[i];\n\n            if (comment.range[1] <= this.range[0]) {\n              leadingComments.unshift(comment);\n              lastChild.leadingComments.splice(i, 1);\n            }\n          }\n\n          if (!lastChild.leadingComments.length) {\n            lastChild.leadingComments = undefined;\n          }\n        }\n      } else if (extra.leadingComments.length > 0) {\n        leadingComments = [];\n\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n\n          if (comment.range[1] <= this.range[0]) {\n            leadingComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n          }\n        }\n      }\n\n      if (leadingComments && leadingComments.length > 0) {\n        this.leadingComments = leadingComments;\n      }\n\n      if (trailingComments && trailingComments.length > 0) {\n        this.trailingComments = trailingComments;\n      }\n\n      bottomRight.push(this);\n    },\n    finish: function finish() {\n      if (extra.range) {\n        this.range[1] = lastIndex;\n      }\n\n      if (extra.loc) {\n        this.loc.end = {\n          line: lastLineNumber,\n          column: lastIndex - lastLineStart\n        };\n\n        if (extra.source) {\n          this.loc.source = extra.source;\n        }\n      }\n\n      if (extra.attachComment) {\n        this.processComment();\n      }\n    },\n    finishArrayExpression: function finishArrayExpression(elements) {\n      this.type = Syntax.ArrayExpression;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrayPattern: function finishArrayPattern(elements) {\n      this.type = Syntax.ArrayPattern;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrowFunctionExpression: function finishArrowFunctionExpression(params, defaults, body, expression) {\n      this.type = Syntax.ArrowFunctionExpression;\n      this.id = null;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishAssignmentExpression: function finishAssignmentExpression(operator, left, right) {\n      this.type = Syntax.AssignmentExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishAssignmentPattern: function finishAssignmentPattern(left, right) {\n      this.type = Syntax.AssignmentPattern;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBinaryExpression: function finishBinaryExpression(operator, left, right) {\n      this.type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBlockStatement: function finishBlockStatement(body) {\n      this.type = Syntax.BlockStatement;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishBreakStatement: function finishBreakStatement(label) {\n      this.type = Syntax.BreakStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishCallExpression: function finishCallExpression(callee, args) {\n      this.type = Syntax.CallExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishCatchClause: function finishCatchClause(param, body) {\n      this.type = Syntax.CatchClause;\n      this.param = param;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassBody: function finishClassBody(body) {\n      this.type = Syntax.ClassBody;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassDeclaration: function finishClassDeclaration(id, superClass, body) {\n      this.type = Syntax.ClassDeclaration;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassExpression: function finishClassExpression(id, superClass, body) {\n      this.type = Syntax.ClassExpression;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishConditionalExpression: function finishConditionalExpression(test, consequent, alternate) {\n      this.type = Syntax.ConditionalExpression;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishContinueStatement: function finishContinueStatement(label) {\n      this.type = Syntax.ContinueStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishDebuggerStatement: function finishDebuggerStatement() {\n      this.type = Syntax.DebuggerStatement;\n      this.finish();\n      return this;\n    },\n    finishDoWhileStatement: function finishDoWhileStatement(body, test) {\n      this.type = Syntax.DoWhileStatement;\n      this.body = body;\n      this.test = test;\n      this.finish();\n      return this;\n    },\n    finishEmptyStatement: function finishEmptyStatement() {\n      this.type = Syntax.EmptyStatement;\n      this.finish();\n      return this;\n    },\n    finishExpressionStatement: function finishExpressionStatement(expression) {\n      this.type = Syntax.ExpressionStatement;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishForStatement: function finishForStatement(init, test, update, body) {\n      this.type = Syntax.ForStatement;\n      this.init = init;\n      this.test = test;\n      this.update = update;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForOfStatement: function finishForOfStatement(left, right, body) {\n      this.type = Syntax.ForOfStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForInStatement: function finishForInStatement(left, right, body) {\n      this.type = Syntax.ForInStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.each = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionDeclaration: function finishFunctionDeclaration(id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionDeclaration;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionExpression: function finishFunctionExpression(id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionExpression;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishIdentifier: function finishIdentifier(name) {\n      this.type = Syntax.Identifier;\n      this.name = name;\n      this.finish();\n      return this;\n    },\n    finishIfStatement: function finishIfStatement(test, consequent, alternate) {\n      this.type = Syntax.IfStatement;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishLabeledStatement: function finishLabeledStatement(label, body) {\n      this.type = Syntax.LabeledStatement;\n      this.label = label;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishLiteral: function finishLiteral(token) {\n      this.type = Syntax.Literal;\n      this.value = token.value;\n      this.raw = source.slice(token.start, token.end);\n\n      if (token.regex) {\n        this.regex = token.regex;\n      }\n\n      this.finish();\n      return this;\n    },\n    finishMemberExpression: function finishMemberExpression(accessor, object, property) {\n      this.type = Syntax.MemberExpression;\n      this.computed = accessor === '[';\n      this.object = object;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishMetaProperty: function finishMetaProperty(meta, property) {\n      this.type = Syntax.MetaProperty;\n      this.meta = meta;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishNewExpression: function finishNewExpression(callee, args) {\n      this.type = Syntax.NewExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishObjectExpression: function finishObjectExpression(properties) {\n      this.type = Syntax.ObjectExpression;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishObjectPattern: function finishObjectPattern(properties) {\n      this.type = Syntax.ObjectPattern;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishPostfixExpression: function finishPostfixExpression(operator, argument) {\n      this.type = Syntax.UpdateExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = false;\n      this.finish();\n      return this;\n    },\n    finishProgram: function finishProgram(body, sourceType) {\n      this.type = Syntax.Program;\n      this.body = body;\n      this.sourceType = sourceType;\n      this.finish();\n      return this;\n    },\n    finishProperty: function finishProperty(kind, key, computed, value, method, shorthand) {\n      this.type = Syntax.Property;\n      this.key = key;\n      this.computed = computed;\n      this.value = value;\n      this.kind = kind;\n      this.method = method;\n      this.shorthand = shorthand;\n      this.finish();\n      return this;\n    },\n    finishRestElement: function finishRestElement(argument) {\n      this.type = Syntax.RestElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishReturnStatement: function finishReturnStatement(argument) {\n      this.type = Syntax.ReturnStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSequenceExpression: function finishSequenceExpression(expressions) {\n      this.type = Syntax.SequenceExpression;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishSpreadElement: function finishSpreadElement(argument) {\n      this.type = Syntax.SpreadElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSwitchCase: function finishSwitchCase(test, consequent) {\n      this.type = Syntax.SwitchCase;\n      this.test = test;\n      this.consequent = consequent;\n      this.finish();\n      return this;\n    },\n    finishSuper: function finishSuper() {\n      this.type = Syntax.Super;\n      this.finish();\n      return this;\n    },\n    finishSwitchStatement: function finishSwitchStatement(discriminant, cases) {\n      this.type = Syntax.SwitchStatement;\n      this.discriminant = discriminant;\n      this.cases = cases;\n      this.finish();\n      return this;\n    },\n    finishTaggedTemplateExpression: function finishTaggedTemplateExpression(tag, quasi) {\n      this.type = Syntax.TaggedTemplateExpression;\n      this.tag = tag;\n      this.quasi = quasi;\n      this.finish();\n      return this;\n    },\n    finishTemplateElement: function finishTemplateElement(value, tail) {\n      this.type = Syntax.TemplateElement;\n      this.value = value;\n      this.tail = tail;\n      this.finish();\n      return this;\n    },\n    finishTemplateLiteral: function finishTemplateLiteral(quasis, expressions) {\n      this.type = Syntax.TemplateLiteral;\n      this.quasis = quasis;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishThisExpression: function finishThisExpression() {\n      this.type = Syntax.ThisExpression;\n      this.finish();\n      return this;\n    },\n    finishThrowStatement: function finishThrowStatement(argument) {\n      this.type = Syntax.ThrowStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishTryStatement: function finishTryStatement(block, handler, finalizer) {\n      this.type = Syntax.TryStatement;\n      this.block = block;\n      this.guardedHandlers = [];\n      this.handlers = handler ? [handler] : [];\n      this.handler = handler;\n      this.finalizer = finalizer;\n      this.finish();\n      return this;\n    },\n    finishUnaryExpression: function finishUnaryExpression(operator, argument) {\n      this.type = operator === '++' || operator === '--' ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = true;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclaration: function finishVariableDeclaration(declarations) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = 'var';\n      this.finish();\n      return this;\n    },\n    finishLexicalDeclaration: function finishLexicalDeclaration(declarations, kind) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = kind;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclarator: function finishVariableDeclarator(id, init) {\n      this.type = Syntax.VariableDeclarator;\n      this.id = id;\n      this.init = init;\n      this.finish();\n      return this;\n    },\n    finishWhileStatement: function finishWhileStatement(test, body) {\n      this.type = Syntax.WhileStatement;\n      this.test = test;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishWithStatement: function finishWithStatement(object, body) {\n      this.type = Syntax.WithStatement;\n      this.object = object;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishExportSpecifier: function finishExportSpecifier(local, exported) {\n      this.type = Syntax.ExportSpecifier;\n      this.exported = exported || local;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportDefaultSpecifier: function finishImportDefaultSpecifier(local) {\n      this.type = Syntax.ImportDefaultSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportNamespaceSpecifier: function finishImportNamespaceSpecifier(local) {\n      this.type = Syntax.ImportNamespaceSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishExportNamedDeclaration: function finishExportNamedDeclaration(declaration, specifiers, src) {\n      this.type = Syntax.ExportNamedDeclaration;\n      this.declaration = declaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishExportDefaultDeclaration: function finishExportDefaultDeclaration(declaration) {\n      this.type = Syntax.ExportDefaultDeclaration;\n      this.declaration = declaration;\n      this.finish();\n      return this;\n    },\n    finishExportAllDeclaration: function finishExportAllDeclaration(src) {\n      this.type = Syntax.ExportAllDeclaration;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishImportSpecifier: function finishImportSpecifier(local, imported) {\n      this.type = Syntax.ImportSpecifier;\n      this.local = local || imported;\n      this.imported = imported;\n      this.finish();\n      return this;\n    },\n    finishImportDeclaration: function finishImportDeclaration(specifiers, src) {\n      this.type = Syntax.ImportDeclaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishYieldExpression: function finishYieldExpression(argument, delegate) {\n      this.type = Syntax.YieldExpression;\n      this.argument = argument;\n      this.delegate = delegate;\n      this.finish();\n      return this;\n    }\n  };\n\n  function recordError(error) {\n    var e, existing;\n\n    for (e = 0; e < extra.errors.length; e++) {\n      existing = extra.errors[e]; // Prevent duplicated error.\n\n      /* istanbul ignore next */\n\n      if (existing.index === error.index && existing.message === error.message) {\n        return;\n      }\n    }\n\n    extra.errors.push(error);\n  }\n\n  function constructError(msg, column) {\n    var error = new Error(msg);\n\n    try {\n      throw error;\n    } catch (base) {\n      /* istanbul ignore else */\n      if (Object.create && Object.defineProperty) {\n        error = Object.create(base);\n        Object.defineProperty(error, 'column', {\n          value: column\n        });\n      }\n    } finally {\n      return error;\n    }\n  }\n\n  function createError(line, pos, description) {\n    var msg, column, error;\n    msg = 'Line ' + line + ': ' + description;\n    column = pos - (scanning ? lineStart : lastLineStart) + 1;\n    error = constructError(msg, column);\n    error.lineNumber = line;\n    error.description = description;\n    error.index = pos;\n    return error;\n  } // Throw an exception\n\n\n  function throwError(messageFormat) {\n    var args, msg;\n    args = Array.prototype.slice.call(arguments, 1);\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    throw createError(lastLineNumber, lastIndex, msg);\n  }\n\n  function tolerateError(messageFormat) {\n    var args, msg, error;\n    args = Array.prototype.slice.call(arguments, 1);\n    /* istanbul ignore next */\n\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    error = createError(lineNumber, lastIndex, msg);\n\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  } // Throw an exception because of the token.\n\n\n  function unexpectedTokenError(token, message) {\n    var value,\n        msg = message || Messages.UnexpectedToken;\n\n    if (token) {\n      if (!message) {\n        msg = token.type === Token.EOF ? Messages.UnexpectedEOS : token.type === Token.Identifier ? Messages.UnexpectedIdentifier : token.type === Token.NumericLiteral ? Messages.UnexpectedNumber : token.type === Token.StringLiteral ? Messages.UnexpectedString : token.type === Token.Template ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;\n\n        if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n            msg = Messages.UnexpectedReserved;\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n            msg = Messages.StrictReservedWord;\n          }\n        }\n      }\n\n      value = token.type === Token.Template ? token.value.raw : token.value;\n    } else {\n      value = 'ILLEGAL';\n    }\n\n    msg = msg.replace('%0', value);\n    return token && typeof token.lineNumber === 'number' ? createError(token.lineNumber, token.start, msg) : createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n  }\n\n  function throwUnexpectedToken(token, message) {\n    throw unexpectedTokenError(token, message);\n  }\n\n  function tolerateUnexpectedToken(token, message) {\n    var error = unexpectedTokenError(token, message);\n\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  } // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n\n  function expect(value) {\n    var token = lex();\n\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpectedToken(token);\n    }\n  }\n  /**\n   * @name expectCommaSeparator\n   * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @since 2.0\n   */\n\n\n  function expectCommaSeparator() {\n    var token;\n\n    if (extra.errors) {\n      token = lookahead;\n\n      if (token.type === Token.Punctuator && token.value === ',') {\n        lex();\n      } else if (token.type === Token.Punctuator && token.value === ';') {\n        lex();\n        tolerateUnexpectedToken(token);\n      } else {\n        tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n      }\n    } else {\n      expect(',');\n    }\n  } // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n\n  function expectKeyword(keyword) {\n    var token = lex();\n\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpectedToken(token);\n    }\n  } // Return true if the next token matches the specified punctuator.\n\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  } // Return true if the next token matches the specified keyword\n\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  } // Return true if the next token matches the specified contextual keyword\n  // (where an identifier is sometimes a keyword depending on the context)\n\n\n  function matchContextualKeyword(keyword) {\n    return lookahead.type === Token.Identifier && lookahead.value === keyword;\n  } // Return true if the next token is an assignment operator\n\n\n  function matchAssign() {\n    var op;\n\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  function consumeSemicolon() {\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n\n    if (hasLineTerminator) {\n      return;\n    } // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n\n\n    lastIndex = startIndex;\n    lastLineNumber = startLineNumber;\n    lastLineStart = startLineStart;\n\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpectedToken(lookahead);\n    }\n  } // Cover grammar support.\n  //\n  // When an assignment expression position starts with an left parenthesis, the determination of the type\n  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n  //\n  // There are three productions that can be parsed in a parentheses pair that needs to be determined\n  // after the outermost pair is closed. They are:\n  //\n  //   1. AssignmentExpression\n  //   2. BindingElements\n  //   3. AssignmentTargets\n  //\n  // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n  // binding element or assignment target.\n  //\n  // The three productions have the relationship:\n  //\n  //   BindingElements  AssignmentTargets  AssignmentExpression\n  //\n  // with a single exception that CoverInitializedName when used directly in an Expression, generates\n  // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n  // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n  //\n  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n  // the CoverInitializedName check is conducted.\n  //\n  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n  // pattern. The CoverInitializedName check is deferred.\n\n\n  function isolateCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n        oldIsAssignmentTarget = isAssignmentTarget,\n        oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n        result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n\n    if (firstCoverInitializedNameError !== null) {\n      throwUnexpectedToken(firstCoverInitializedNameError);\n    }\n\n    isBindingElement = oldIsBindingElement;\n    isAssignmentTarget = oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n    return result;\n  }\n\n  function inheritCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n        oldIsAssignmentTarget = isAssignmentTarget,\n        oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n        result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    isBindingElement = isBindingElement && oldIsBindingElement;\n    isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n    return result;\n  } // ECMA-262 13.3.3 Destructuring Binding Patterns\n\n\n  function parseArrayPattern(params, kind) {\n    var node = new Node(),\n        elements = [],\n        rest,\n        restNode;\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        if (match('...')) {\n          restNode = new Node();\n          lex();\n          params.push(lookahead);\n          rest = parseVariableIdentifier(kind);\n          elements.push(restNode.finishRestElement(rest));\n          break;\n        } else {\n          elements.push(parsePatternWithDefault(params, kind));\n        }\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    expect(']');\n    return node.finishArrayPattern(elements);\n  }\n\n  function parsePropertyPattern(params, kind) {\n    var node = new Node(),\n        key,\n        keyToken,\n        computed = match('['),\n        init;\n\n    if (lookahead.type === Token.Identifier) {\n      keyToken = lookahead;\n      key = parseVariableIdentifier();\n\n      if (match('=')) {\n        params.push(keyToken);\n        lex();\n        init = parseAssignmentExpression();\n        return node.finishProperty('init', key, false, new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);\n      } else if (!match(':')) {\n        params.push(keyToken);\n        return node.finishProperty('init', key, false, key, false, true);\n      }\n    } else {\n      key = parseObjectPropertyKey();\n    }\n\n    expect(':');\n    init = parsePatternWithDefault(params, kind);\n    return node.finishProperty('init', key, computed, init, false, false);\n  }\n\n  function parseObjectPattern(params, kind) {\n    var node = new Node(),\n        properties = [];\n    expect('{');\n\n    while (!match('}')) {\n      properties.push(parsePropertyPattern(params, kind));\n\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n\n    lex();\n    return node.finishObjectPattern(properties);\n  }\n\n  function parsePattern(params, kind) {\n    if (match('[')) {\n      return parseArrayPattern(params, kind);\n    } else if (match('{')) {\n      return parseObjectPattern(params, kind);\n    } else if (matchKeyword('let')) {\n      if (kind === 'const' || kind === 'let') {\n        tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);\n      }\n    }\n\n    params.push(lookahead);\n    return parseVariableIdentifier(kind);\n  }\n\n  function parsePatternWithDefault(params, kind) {\n    var startToken = lookahead,\n        pattern,\n        previousAllowYield,\n        right;\n    pattern = parsePattern(params, kind);\n\n    if (match('=')) {\n      lex();\n      previousAllowYield = state.allowYield;\n      state.allowYield = true;\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowYield = previousAllowYield;\n      pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n    }\n\n    return pattern;\n  } // ECMA-262 12.2.5 Array Initializer\n\n\n  function parseArrayInitializer() {\n    var elements = [],\n        node = new Node(),\n        restSpread;\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else if (match('...')) {\n        restSpread = new Node();\n        lex();\n        restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n        if (!match(']')) {\n          isAssignmentTarget = isBindingElement = false;\n          expect(',');\n        }\n\n        elements.push(restSpread);\n      } else {\n        elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    lex();\n    return node.finishArrayExpression(elements);\n  } // ECMA-262 12.2.6 Object Initializer\n\n\n  function parsePropertyFunction(node, paramInfo, isGenerator) {\n    var previousStrict, body;\n    isAssignmentTarget = isBindingElement = false;\n    previousStrict = strict;\n    body = isolateCoverGrammar(parseFunctionSourceElements);\n\n    if (strict && paramInfo.firstRestricted) {\n      tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n    }\n\n    if (strict && paramInfo.stricted) {\n      tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n    }\n\n    strict = previousStrict;\n    return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n  }\n\n  function parsePropertyMethodFunction() {\n    var params,\n        method,\n        node = new Node(),\n        previousAllowYield = state.allowYield;\n    state.allowYield = false;\n    params = parseParams();\n    state.allowYield = previousAllowYield;\n    state.allowYield = false;\n    method = parsePropertyFunction(node, params, false);\n    state.allowYield = previousAllowYield;\n    return method;\n  }\n\n  function parseObjectPropertyKey() {\n    var token,\n        node = new Node(),\n        expr;\n    token = lex(); // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    switch (token.type) {\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        if (strict && token.octal) {\n          tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n        }\n\n        return node.finishLiteral(token);\n\n      case Token.Identifier:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.Keyword:\n        return node.finishIdentifier(token.value);\n\n      case Token.Punctuator:\n        if (token.value === '[') {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n          expect(']');\n          return expr;\n        }\n\n        break;\n    }\n\n    throwUnexpectedToken(token);\n  }\n\n  function lookaheadPropertyName() {\n    switch (lookahead.type) {\n      case Token.Identifier:\n      case Token.StringLiteral:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.NumericLiteral:\n      case Token.Keyword:\n        return true;\n\n      case Token.Punctuator:\n        return lookahead.value === '[';\n    }\n\n    return false;\n  } // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n  // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n  // This can only be determined after we consumed up to the left parentheses.\n  //\n  // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n  // is responsible to visit other options.\n\n\n  function tryParseMethodDefinition(token, key, computed, node) {\n    var value,\n        options,\n        methodNode,\n        params,\n        previousAllowYield = state.allowYield;\n\n    if (token.type === Token.Identifier) {\n      // check for `get` and `set`;\n      if (token.value === 'get' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, {\n          params: [],\n          defaults: [],\n          stricted: null,\n          firstRestricted: null,\n          message: null\n        }, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('get', key, computed, value, false, false);\n      } else if (token.value === 'set' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        options = {\n          params: [],\n          defaultCount: 0,\n          defaults: [],\n          firstRestricted: null,\n          paramSet: {}\n        };\n\n        if (match(')')) {\n          tolerateUnexpectedToken(lookahead);\n        } else {\n          state.allowYield = false;\n          parseParam(options);\n          state.allowYield = previousAllowYield;\n\n          if (options.defaultCount === 0) {\n            options.defaults = [];\n          }\n        }\n\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, options, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('set', key, computed, value, false, false);\n      }\n    } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n      computed = match('[');\n      key = parseObjectPropertyKey();\n      methodNode = new Node();\n      state.allowYield = true;\n      params = parseParams();\n      state.allowYield = previousAllowYield;\n      state.allowYield = false;\n      value = parsePropertyFunction(methodNode, params, true);\n      state.allowYield = previousAllowYield;\n      return node.finishProperty('init', key, computed, value, true, false);\n    }\n\n    if (key && match('(')) {\n      value = parsePropertyMethodFunction();\n      return node.finishProperty('init', key, computed, value, true, false);\n    } // Not a MethodDefinition.\n\n\n    return null;\n  }\n\n  function parseObjectProperty(hasProto) {\n    var token = lookahead,\n        node = new Node(),\n        computed,\n        key,\n        maybeMethod,\n        proto,\n        value;\n    computed = match('[');\n\n    if (match('*')) {\n      lex();\n    } else {\n      key = parseObjectPropertyKey();\n    }\n\n    maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n\n    if (maybeMethod) {\n      return maybeMethod;\n    }\n\n    if (!key) {\n      throwUnexpectedToken(lookahead);\n    } // Check for duplicated __proto__\n\n\n    if (!computed) {\n      proto = key.type === Syntax.Identifier && key.name === '__proto__' || key.type === Syntax.Literal && key.value === '__proto__';\n\n      if (hasProto.value && proto) {\n        tolerateError(Messages.DuplicateProtoProperty);\n      }\n\n      hasProto.value |= proto;\n    }\n\n    if (match(':')) {\n      lex();\n      value = inheritCoverGrammar(parseAssignmentExpression);\n      return node.finishProperty('init', key, computed, value, false, false);\n    }\n\n    if (token.type === Token.Identifier) {\n      if (match('=')) {\n        firstCoverInitializedNameError = lookahead;\n        lex();\n        value = isolateCoverGrammar(parseAssignmentExpression);\n        return node.finishProperty('init', key, computed, new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n      }\n\n      return node.finishProperty('init', key, computed, key, false, true);\n    }\n\n    throwUnexpectedToken(lookahead);\n  }\n\n  function parseObjectInitializer() {\n    var properties = [],\n        hasProto = {\n      value: false\n    },\n        node = new Node();\n    expect('{');\n\n    while (!match('}')) {\n      properties.push(parseObjectProperty(hasProto));\n\n      if (!match('}')) {\n        expectCommaSeparator();\n      }\n    }\n\n    expect('}');\n    return node.finishObjectExpression(properties);\n  }\n\n  function reinterpretExpressionAsPattern(expr) {\n    var i;\n\n    switch (expr.type) {\n      case Syntax.Identifier:\n      case Syntax.MemberExpression:\n      case Syntax.RestElement:\n      case Syntax.AssignmentPattern:\n        break;\n\n      case Syntax.SpreadElement:\n        expr.type = Syntax.RestElement;\n        reinterpretExpressionAsPattern(expr.argument);\n        break;\n\n      case Syntax.ArrayExpression:\n        expr.type = Syntax.ArrayPattern;\n\n        for (i = 0; i < expr.elements.length; i++) {\n          if (expr.elements[i] !== null) {\n            reinterpretExpressionAsPattern(expr.elements[i]);\n          }\n        }\n\n        break;\n\n      case Syntax.ObjectExpression:\n        expr.type = Syntax.ObjectPattern;\n\n        for (i = 0; i < expr.properties.length; i++) {\n          reinterpretExpressionAsPattern(expr.properties[i].value);\n        }\n\n        break;\n\n      case Syntax.AssignmentExpression:\n        expr.type = Syntax.AssignmentPattern;\n        reinterpretExpressionAsPattern(expr.left);\n        break;\n\n      default:\n        // Allow other node type for tolerant parsing.\n        break;\n    }\n  } // ECMA-262 12.2.9 Template Literals\n\n\n  function parseTemplateElement(option) {\n    var node, token;\n\n    if (lookahead.type !== Token.Template || option.head && !lookahead.head) {\n      throwUnexpectedToken();\n    }\n\n    node = new Node();\n    token = lex();\n    return node.finishTemplateElement({\n      raw: token.value.raw,\n      cooked: token.value.cooked\n    }, token.tail);\n  }\n\n  function parseTemplateLiteral() {\n    var quasi,\n        quasis,\n        expressions,\n        node = new Node();\n    quasi = parseTemplateElement({\n      head: true\n    });\n    quasis = [quasi];\n    expressions = [];\n\n    while (!quasi.tail) {\n      expressions.push(parseExpression());\n      quasi = parseTemplateElement({\n        head: false\n      });\n      quasis.push(quasi);\n    }\n\n    return node.finishTemplateLiteral(quasis, expressions);\n  } // ECMA-262 12.2.10 The Grouping Operator\n\n\n  function parseGroupExpression() {\n    var expr,\n        expressions,\n        startToken,\n        i,\n        params = [];\n    expect('(');\n\n    if (match(')')) {\n      lex();\n\n      if (!match('=>')) {\n        expect('=>');\n      }\n\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [],\n        rawParams: []\n      };\n    }\n\n    startToken = lookahead;\n\n    if (match('...')) {\n      expr = parseRestElement(params);\n      expect(')');\n\n      if (!match('=>')) {\n        expect('=>');\n      }\n\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [expr]\n      };\n    }\n\n    isBindingElement = true;\n    expr = inheritCoverGrammar(parseAssignmentExpression);\n\n    if (match(',')) {\n      isAssignmentTarget = false;\n      expressions = [expr];\n\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n\n        if (match('...')) {\n          if (!isBindingElement) {\n            throwUnexpectedToken(lookahead);\n          }\n\n          expressions.push(parseRestElement(params));\n          expect(')');\n\n          if (!match('=>')) {\n            expect('=>');\n          }\n\n          isBindingElement = false;\n\n          for (i = 0; i < expressions.length; i++) {\n            reinterpretExpressionAsPattern(expressions[i]);\n          }\n\n          return {\n            type: PlaceHolders.ArrowParameterPlaceHolder,\n            params: expressions\n          };\n        }\n\n        expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n      }\n\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n\n    expect(')');\n\n    if (match('=>')) {\n      if (expr.type === Syntax.Identifier && expr.name === 'yield') {\n        return {\n          type: PlaceHolders.ArrowParameterPlaceHolder,\n          params: [expr]\n        };\n      }\n\n      if (!isBindingElement) {\n        throwUnexpectedToken(lookahead);\n      }\n\n      if (expr.type === Syntax.SequenceExpression) {\n        for (i = 0; i < expr.expressions.length; i++) {\n          reinterpretExpressionAsPattern(expr.expressions[i]);\n        }\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n\n      expr = {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n      };\n    }\n\n    isBindingElement = false;\n    return expr;\n  } // ECMA-262 12.2 Primary Expressions\n\n\n  function parsePrimaryExpression() {\n    var type, token, expr, node;\n\n    if (match('(')) {\n      isBindingElement = false;\n      return inheritCoverGrammar(parseGroupExpression);\n    }\n\n    if (match('[')) {\n      return inheritCoverGrammar(parseArrayInitializer);\n    }\n\n    if (match('{')) {\n      return inheritCoverGrammar(parseObjectInitializer);\n    }\n\n    type = lookahead.type;\n    node = new Node();\n\n    if (type === Token.Identifier) {\n      if (state.sourceType === 'module' && lookahead.value === 'await') {\n        tolerateUnexpectedToken(lookahead);\n      }\n\n      expr = node.finishIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n\n      if (strict && lookahead.octal) {\n        tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n      }\n\n      expr = node.finishLiteral(lex());\n    } else if (type === Token.Keyword) {\n      if (!strict && state.allowYield && matchKeyword('yield')) {\n        return parseNonComputedProperty();\n      }\n\n      if (!strict && matchKeyword('let')) {\n        return node.finishIdentifier(lex().value);\n      }\n\n      isAssignmentTarget = isBindingElement = false;\n\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n\n      if (matchKeyword('this')) {\n        lex();\n        return node.finishThisExpression();\n      }\n\n      if (matchKeyword('class')) {\n        return parseClassExpression();\n      }\n\n      throwUnexpectedToken(lex());\n    } else if (type === Token.BooleanLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = token.value === 'true';\n      expr = node.finishLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = null;\n      expr = node.finishLiteral(token);\n    } else if (match('/') || match('/=')) {\n      isAssignmentTarget = isBindingElement = false;\n      index = startIndex;\n\n      if (typeof extra.tokens !== 'undefined') {\n        token = collectRegex();\n      } else {\n        token = scanRegExp();\n      }\n\n      lex();\n      expr = node.finishLiteral(token);\n    } else if (type === Token.Template) {\n      expr = parseTemplateLiteral();\n    } else {\n      throwUnexpectedToken(lex());\n    }\n\n    return expr;\n  } // ECMA-262 12.3 Left-Hand-Side Expressions\n\n\n  function parseArguments() {\n    var args = [],\n        expr;\n    expect('(');\n\n    if (!match(')')) {\n      while (startIndex < length) {\n        if (match('...')) {\n          expr = new Node();\n          lex();\n          expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n        } else {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        args.push(expr);\n\n        if (match(')')) {\n          break;\n        }\n\n        expectCommaSeparator();\n      }\n    }\n\n    expect(')');\n    return args;\n  }\n\n  function parseNonComputedProperty() {\n    var token,\n        node = new Node();\n    token = lex();\n\n    if (!isIdentifierName(token)) {\n      throwUnexpectedToken(token);\n    }\n\n    return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = isolateCoverGrammar(parseExpression);\n    expect(']');\n    return expr;\n  } // ECMA-262 12.3.3 The new Operator\n\n\n  function parseNewExpression() {\n    var callee,\n        args,\n        node = new Node();\n    expectKeyword('new');\n\n    if (match('.')) {\n      lex();\n\n      if (lookahead.type === Token.Identifier && lookahead.value === 'target') {\n        if (state.inFunctionBody) {\n          lex();\n          return node.finishMetaProperty('new', 'target');\n        }\n      }\n\n      throwUnexpectedToken(lookahead);\n    }\n\n    callee = isolateCoverGrammar(parseLeftHandSideExpression);\n    args = match('(') ? parseArguments() : [];\n    isAssignmentTarget = isBindingElement = false;\n    return node.finishNewExpression(callee, args);\n  } // ECMA-262 12.3.4 Function Calls\n\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var quasi,\n        expr,\n        args,\n        property,\n        startToken,\n        previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n\n      if (!match('(') && !match('.') && !match('[')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n\n    for (;;) {\n      if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        isBindingElement = false;\n        isAssignmentTarget = false;\n        args = parseArguments();\n        expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n      } else if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n\n    state.allowIn = previousAllowIn;\n    return expr;\n  } // ECMA-262 12.3 Left-Hand-Side Expressions\n\n\n  function parseLeftHandSideExpression() {\n    var quasi, expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n\n      if (!match('[') && !match('.')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n\n    for (;;) {\n      if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n\n    return expr;\n  } // ECMA-262 12.4 Postfix Expressions\n\n\n  function parsePostfixExpression() {\n    var expr,\n        token,\n        startToken = lookahead;\n    expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n    if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n      if (match('++') || match('--')) {\n        // ECMA-262 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          tolerateError(Messages.StrictLHSPostfix);\n        }\n\n        if (!isAssignmentTarget) {\n          tolerateError(Messages.InvalidLHSInAssignment);\n        }\n\n        isAssignmentTarget = isBindingElement = false;\n        token = lex();\n        expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n      }\n    }\n\n    return expr;\n  } // ECMA-262 12.5 Unary Operators\n\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression); // ECMA-262 11.4.4, 11.4.5\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        tolerateError(Messages.StrictLHSPrefix);\n      }\n\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        tolerateError(Messages.StrictDelete);\n      }\n\n      isAssignmentTarget = isBindingElement = false;\n    } else {\n      expr = parsePostfixExpression();\n    }\n\n    return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n\n      case '&&':\n        prec = 2;\n        break;\n\n      case '|':\n        prec = 3;\n        break;\n\n      case '^':\n        prec = 4;\n        break;\n\n      case '&':\n        prec = 5;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n\n      default:\n        break;\n    }\n\n    return prec;\n  } // ECMA-262 12.6 Multiplicative Operators\n  // ECMA-262 12.7 Additive Operators\n  // ECMA-262 12.8 Bitwise Shift Operators\n  // ECMA-262 12.9 Relational Operators\n  // ECMA-262 12.10 Equality Operators\n  // ECMA-262 12.11 Binary Bitwise Operators\n  // ECMA-262 12.12 Binary Logical Operators\n\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = inheritCoverGrammar(parseUnaryExpression);\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n\n    if (prec === 0) {\n      return left;\n    }\n\n    isAssignmentTarget = isBindingElement = false;\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = isolateCoverGrammar(parseUnaryExpression);\n    stack = [left, token, right];\n\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        markers.pop();\n        expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n        stack.push(expr);\n      } // Shift.\n\n\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = isolateCoverGrammar(parseUnaryExpression);\n      stack.push(expr);\n    } // Final reduce to clean-up the stack.\n\n\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n\n    while (i > 1) {\n      expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n    }\n\n    return expr;\n  } // ECMA-262 12.13 Conditional Operator\n\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = inheritCoverGrammar(parseBinaryExpression);\n\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      isAssignmentTarget = isBindingElement = false;\n    }\n\n    return expr;\n  } // ECMA-262 14.2 Arrow Function Definitions\n\n\n  function parseConciseBody() {\n    if (match('{')) {\n      return parseFunctionSourceElements();\n    }\n\n    return isolateCoverGrammar(parseAssignmentExpression);\n  }\n\n  function checkPatternParam(options, param) {\n    var i;\n\n    switch (param.type) {\n      case Syntax.Identifier:\n        validateParam(options, param, param.name);\n        break;\n\n      case Syntax.RestElement:\n        checkPatternParam(options, param.argument);\n        break;\n\n      case Syntax.AssignmentPattern:\n        checkPatternParam(options, param.left);\n        break;\n\n      case Syntax.ArrayPattern:\n        for (i = 0; i < param.elements.length; i++) {\n          if (param.elements[i] !== null) {\n            checkPatternParam(options, param.elements[i]);\n          }\n        }\n\n        break;\n\n      case Syntax.YieldExpression:\n        break;\n\n      default:\n        assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n\n        for (i = 0; i < param.properties.length; i++) {\n          checkPatternParam(options, param.properties[i].value);\n        }\n\n        break;\n    }\n  }\n\n  function reinterpretAsCoverFormalsList(expr) {\n    var i, len, param, params, defaults, defaultCount, options, token;\n    defaults = [];\n    defaultCount = 0;\n    params = [expr];\n\n    switch (expr.type) {\n      case Syntax.Identifier:\n        break;\n\n      case PlaceHolders.ArrowParameterPlaceHolder:\n        params = expr.params;\n        break;\n\n      default:\n        return null;\n    }\n\n    options = {\n      paramSet: {}\n    };\n\n    for (i = 0, len = params.length; i < len; i += 1) {\n      param = params[i];\n\n      switch (param.type) {\n        case Syntax.AssignmentPattern:\n          params[i] = param.left;\n\n          if (param.right.type === Syntax.YieldExpression) {\n            if (param.right.argument) {\n              throwUnexpectedToken(lookahead);\n            }\n\n            param.right.type = Syntax.Identifier;\n            param.right.name = 'yield';\n            delete param.right.argument;\n            delete param.right.delegate;\n          }\n\n          defaults.push(param.right);\n          ++defaultCount;\n          checkPatternParam(options, param.left);\n          break;\n\n        default:\n          checkPatternParam(options, param);\n          params[i] = param;\n          defaults.push(null);\n          break;\n      }\n    }\n\n    if (strict || !state.allowYield) {\n      for (i = 0, len = params.length; i < len; i += 1) {\n        param = params[i];\n\n        if (param.type === Syntax.YieldExpression) {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n\n    if (options.message === Messages.StrictParamDupe) {\n      token = strict ? options.stricted : options.firstRestricted;\n      throwUnexpectedToken(token, options.message);\n    }\n\n    if (defaultCount === 0) {\n      defaults = [];\n    }\n\n    return {\n      params: params,\n      defaults: defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n\n  function parseArrowFunctionExpression(options, node) {\n    var previousStrict, previousAllowYield, body;\n\n    if (hasLineTerminator) {\n      tolerateUnexpectedToken(lookahead);\n    }\n\n    expect('=>');\n    previousStrict = strict;\n    previousAllowYield = state.allowYield;\n    state.allowYield = true;\n    body = parseConciseBody();\n\n    if (strict && options.firstRestricted) {\n      throwUnexpectedToken(options.firstRestricted, options.message);\n    }\n\n    if (strict && options.stricted) {\n      tolerateUnexpectedToken(options.stricted, options.message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n  } // ECMA-262 14.4 Yield expression\n\n\n  function parseYieldExpression() {\n    var argument, expr, delegate, previousAllowYield;\n    argument = null;\n    expr = new Node();\n    delegate = false;\n    expectKeyword('yield');\n\n    if (!hasLineTerminator) {\n      previousAllowYield = state.allowYield;\n      state.allowYield = false;\n      delegate = match('*');\n\n      if (delegate) {\n        lex();\n        argument = parseAssignmentExpression();\n      } else {\n        if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {\n          argument = parseAssignmentExpression();\n        }\n      }\n\n      state.allowYield = previousAllowYield;\n    }\n\n    return expr.finishYieldExpression(argument, delegate);\n  } // ECMA-262 12.14 Assignment Operators\n\n\n  function parseAssignmentExpression() {\n    var token, expr, right, list, startToken;\n    startToken = lookahead;\n    token = lookahead;\n\n    if (!state.allowYield && matchKeyword('yield')) {\n      return parseYieldExpression();\n    }\n\n    expr = parseConditionalExpression();\n\n    if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n      isAssignmentTarget = isBindingElement = false;\n      list = reinterpretAsCoverFormalsList(expr);\n\n      if (list) {\n        firstCoverInitializedNameError = null;\n        return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n      }\n\n      return expr;\n    }\n\n    if (matchAssign()) {\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      } // ECMA-262 12.1.1\n\n\n      if (strict && expr.type === Syntax.Identifier) {\n        if (isRestrictedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n        }\n\n        if (isStrictModeReservedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n        }\n      }\n\n      if (!match('=')) {\n        isAssignmentTarget = isBindingElement = false;\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n\n      token = lex();\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n      firstCoverInitializedNameError = null;\n    }\n\n    return expr;\n  } // ECMA-262 12.15 Comma Operator\n\n\n  function parseExpression() {\n    var expr,\n        startToken = lookahead,\n        expressions;\n    expr = isolateCoverGrammar(parseAssignmentExpression);\n\n    if (match(',')) {\n      expressions = [expr];\n\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n        expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n      }\n\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n\n    return expr;\n  } // ECMA-262 13.2 Block\n\n\n  function parseStatementListItem() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'export':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n          }\n\n          return parseExportDeclaration();\n\n        case 'import':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n          }\n\n          return parseImportDeclaration();\n\n        case 'const':\n          return parseLexicalDeclaration({\n            inFor: false\n          });\n\n        case 'function':\n          return parseFunctionDeclaration(new Node());\n\n        case 'class':\n          return parseClassDeclaration();\n      }\n    }\n\n    if (matchKeyword('let') && isLexicalDeclaration()) {\n      return parseLexicalDeclaration({\n        inFor: false\n      });\n    }\n\n    return parseStatement();\n  }\n\n  function parseStatementList() {\n    var list = [];\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      list.push(parseStatementListItem());\n    }\n\n    return list;\n  }\n\n  function parseBlock() {\n    var block,\n        node = new Node();\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return node.finishBlockStatement(block);\n  } // ECMA-262 13.3.2 Variable Statement\n\n\n  function parseVariableIdentifier(kind) {\n    var token,\n        node = new Node();\n    token = lex();\n\n    if (token.type === Token.Keyword && token.value === 'yield') {\n      if (strict) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      }\n\n      if (!state.allowYield) {\n        throwUnexpectedToken(token);\n      }\n    } else if (token.type !== Token.Identifier) {\n      if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else {\n        if (strict || token.value !== 'let' || kind !== 'var') {\n          throwUnexpectedToken(token);\n        }\n      }\n    } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {\n      tolerateUnexpectedToken(token);\n    }\n\n    return node.finishIdentifier(token.value);\n  }\n\n  function parseVariableDeclaration(options) {\n    var init = null,\n        id,\n        node = new Node(),\n        params = [];\n    id = parsePattern(params, 'var'); // ECMA-262 12.2.1\n\n    if (strict && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n\n    if (match('=')) {\n      lex();\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    } else if (id.type !== Syntax.Identifier && !options.inFor) {\n      expect('=');\n    }\n\n    return node.finishVariableDeclarator(id, init);\n  }\n\n  function parseVariableDeclarationList(options) {\n    var opt, list;\n    opt = {\n      inFor: options.inFor\n    };\n    list = [parseVariableDeclaration(opt)];\n\n    while (match(',')) {\n      lex();\n      list.push(parseVariableDeclaration(opt));\n    }\n\n    return list;\n  }\n\n  function parseVariableStatement(node) {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList({\n      inFor: false\n    });\n    consumeSemicolon();\n    return node.finishVariableDeclaration(declarations);\n  } // ECMA-262 13.3.1 Let and Const Declarations\n\n\n  function parseLexicalBinding(kind, options) {\n    var init = null,\n        id,\n        node = new Node(),\n        params = [];\n    id = parsePattern(params, kind); // ECMA-262 12.2.1\n\n    if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n\n    if (kind === 'const') {\n      if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n        expect('=');\n        init = isolateCoverGrammar(parseAssignmentExpression);\n      }\n    } else if (!options.inFor && id.type !== Syntax.Identifier || match('=')) {\n      expect('=');\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    return node.finishVariableDeclarator(id, init);\n  }\n\n  function parseBindingList(kind, options) {\n    var list = [parseLexicalBinding(kind, options)];\n\n    while (match(',')) {\n      lex();\n      list.push(parseLexicalBinding(kind, options));\n    }\n\n    return list;\n  }\n\n  function tokenizerState() {\n    return {\n      index: index,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      hasLineTerminator: hasLineTerminator,\n      lastIndex: lastIndex,\n      lastLineNumber: lastLineNumber,\n      lastLineStart: lastLineStart,\n      startIndex: startIndex,\n      startLineNumber: startLineNumber,\n      startLineStart: startLineStart,\n      lookahead: lookahead,\n      tokenCount: extra.tokens ? extra.tokens.length : 0\n    };\n  }\n\n  function resetTokenizerState(ts) {\n    index = ts.index;\n    lineNumber = ts.lineNumber;\n    lineStart = ts.lineStart;\n    hasLineTerminator = ts.hasLineTerminator;\n    lastIndex = ts.lastIndex;\n    lastLineNumber = ts.lastLineNumber;\n    lastLineStart = ts.lastLineStart;\n    startIndex = ts.startIndex;\n    startLineNumber = ts.startLineNumber;\n    startLineStart = ts.startLineStart;\n    lookahead = ts.lookahead;\n\n    if (extra.tokens) {\n      extra.tokens.splice(ts.tokenCount, extra.tokens.length);\n    }\n  }\n\n  function isLexicalDeclaration() {\n    var lexical, ts;\n    ts = tokenizerState();\n    lex();\n    lexical = lookahead.type === Token.Identifier || match('[') || match('{') || matchKeyword('let') || matchKeyword('yield');\n    resetTokenizerState(ts);\n    return lexical;\n  }\n\n  function parseLexicalDeclaration(options) {\n    var kind,\n        declarations,\n        node = new Node();\n    kind = lex().value;\n    assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n    declarations = parseBindingList(kind, options);\n    consumeSemicolon();\n    return node.finishLexicalDeclaration(declarations, kind);\n  }\n\n  function parseRestElement(params) {\n    var param,\n        node = new Node();\n    lex();\n\n    if (match('{')) {\n      throwError(Messages.ObjectPatternAsRestParameter);\n    }\n\n    params.push(lookahead);\n    param = parseVariableIdentifier();\n\n    if (match('=')) {\n      throwError(Messages.DefaultRestParameter);\n    }\n\n    if (!match(')')) {\n      throwError(Messages.ParameterAfterRestParameter);\n    }\n\n    return node.finishRestElement(param);\n  } // ECMA-262 13.4 Empty Statement\n\n\n  function parseEmptyStatement(node) {\n    expect(';');\n    return node.finishEmptyStatement();\n  } // ECMA-262 12.4 Expression Statement\n\n\n  function parseExpressionStatement(node) {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  } // ECMA-262 13.6 If statement\n\n\n  function parseIfStatement(node) {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n\n    return node.finishIfStatement(test, consequent, alternate);\n  } // ECMA-262 13.7 Iteration Statements\n\n\n  function parseDoWhileStatement(node) {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n\n    if (match(';')) {\n      lex();\n    }\n\n    return node.finishDoWhileStatement(body, test);\n  }\n\n  function parseWhileStatement(node) {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return node.finishWhileStatement(test, body);\n  }\n\n  function parseForStatement(node) {\n    var init,\n        forIn,\n        initSeq,\n        initStartToken,\n        test,\n        update,\n        left,\n        right,\n        kind,\n        declarations,\n        body,\n        oldInIteration,\n        previousAllowIn = state.allowIn;\n    init = test = update = null;\n    forIn = true;\n    expectKeyword('for');\n    expect('(');\n\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var')) {\n        init = new Node();\n        lex();\n        state.allowIn = false;\n        declarations = parseVariableDeclarationList({\n          inFor: true\n        });\n        state.allowIn = previousAllowIn;\n\n        if (declarations.length === 1 && matchKeyword('in')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          init = init.finishVariableDeclaration(declarations);\n          expect(';');\n        }\n      } else if (matchKeyword('const') || matchKeyword('let')) {\n        init = new Node();\n        kind = lex().value;\n\n        if (!strict && lookahead.value === 'in') {\n          init = init.finishIdentifier(kind);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          state.allowIn = false;\n          declarations = parseBindingList(kind, {\n            inFor: true\n          });\n          state.allowIn = previousAllowIn;\n\n          if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseExpression();\n            init = null;\n          } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseAssignmentExpression();\n            init = null;\n            forIn = false;\n          } else {\n            consumeSemicolon();\n            init = init.finishLexicalDeclaration(declarations, kind);\n          }\n        }\n      } else {\n        initStartToken = lookahead;\n        state.allowIn = false;\n        init = inheritCoverGrammar(parseAssignmentExpression);\n        state.allowIn = previousAllowIn;\n\n        if (matchKeyword('in')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForIn);\n          }\n\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (matchContextualKeyword('of')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForLoop);\n          }\n\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          if (match(',')) {\n            initSeq = [init];\n\n            while (match(',')) {\n              lex();\n              initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n          }\n\n          expect(';');\n        }\n      }\n    }\n\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n\n      expect(';');\n\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = isolateCoverGrammar(parseStatement);\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? node.finishForStatement(init, test, update, body) : forIn ? node.finishForInStatement(left, right, body) : node.finishForOfStatement(left, right, body);\n  } // ECMA-262 13.8 The continue statement\n\n\n  function parseContinueStatement(node) {\n    var label = null,\n        key;\n    expectKeyword('continue'); // Optimize the most common form: 'continue;'.\n\n    if (source.charCodeAt(startIndex) === 0x3B) {\n      lex();\n\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n\n      return node.finishContinueStatement(null);\n    }\n\n    if (hasLineTerminator) {\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n\n      return node.finishContinueStatement(null);\n    }\n\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !state.inIteration) {\n      throwError(Messages.IllegalContinue);\n    }\n\n    return node.finishContinueStatement(label);\n  } // ECMA-262 13.9 The break statement\n\n\n  function parseBreakStatement(node) {\n    var label = null,\n        key;\n    expectKeyword('break'); // Catch the very common case first: immediately a semicolon (U+003B).\n\n    if (source.charCodeAt(lastIndex) === 0x3B) {\n      lex();\n\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n\n      return node.finishBreakStatement(null);\n    }\n\n    if (hasLineTerminator) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n    } else if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError(Messages.IllegalBreak);\n    }\n\n    return node.finishBreakStatement(label);\n  } // ECMA-262 13.10 The return statement\n\n\n  function parseReturnStatement(node) {\n    var argument = null;\n    expectKeyword('return');\n\n    if (!state.inFunctionBody) {\n      tolerateError(Messages.IllegalReturn);\n    } // 'return' followed by a space and an identifier is very common.\n\n\n    if (source.charCodeAt(lastIndex) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return node.finishReturnStatement(argument);\n      }\n    }\n\n    if (hasLineTerminator) {\n      // HACK\n      return node.finishReturnStatement(null);\n    }\n\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n\n    consumeSemicolon();\n    return node.finishReturnStatement(argument);\n  } // ECMA-262 13.11 The with statement\n\n\n  function parseWithStatement(node) {\n    var object, body;\n\n    if (strict) {\n      tolerateError(Messages.StrictModeWith);\n    }\n\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return node.finishWithStatement(object, body);\n  } // ECMA-262 13.12 The switch statement\n\n\n  function parseSwitchCase() {\n    var test,\n        consequent = [],\n        statement,\n        node = new Node();\n\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n\n    expect(':');\n\n    while (startIndex < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n\n      statement = parseStatementListItem();\n      consequent.push(statement);\n    }\n\n    return node.finishSwitchCase(test, consequent);\n  }\n\n  function parseSwitchStatement(node) {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n\n    if (match('}')) {\n      lex();\n      return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      clause = parseSwitchCase();\n\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError(Messages.MultipleDefaultsInSwitch);\n        }\n\n        defaultFound = true;\n      }\n\n      cases.push(clause);\n    }\n\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return node.finishSwitchStatement(discriminant, cases);\n  } // ECMA-262 13.14 The throw statement\n\n\n  function parseThrowStatement(node) {\n    var argument;\n    expectKeyword('throw');\n\n    if (hasLineTerminator) {\n      throwError(Messages.NewlineAfterThrow);\n    }\n\n    argument = parseExpression();\n    consumeSemicolon();\n    return node.finishThrowStatement(argument);\n  } // ECMA-262 13.15 The try statement\n\n\n  function parseCatchClause() {\n    var param,\n        params = [],\n        paramMap = {},\n        key,\n        i,\n        body,\n        node = new Node();\n    expectKeyword('catch');\n    expect('(');\n\n    if (match(')')) {\n      throwUnexpectedToken(lookahead);\n    }\n\n    param = parsePattern(params);\n\n    for (i = 0; i < params.length; i++) {\n      key = '$' + params[i].value;\n\n      if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n        tolerateError(Messages.DuplicateBinding, params[i].value);\n      }\n\n      paramMap[key] = true;\n    } // ECMA-262 12.14.1\n\n\n    if (strict && isRestrictedWord(param.name)) {\n      tolerateError(Messages.StrictCatchVariable);\n    }\n\n    expect(')');\n    body = parseBlock();\n    return node.finishCatchClause(param, body);\n  }\n\n  function parseTryStatement(node) {\n    var block,\n        handler = null,\n        finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n\n    if (matchKeyword('catch')) {\n      handler = parseCatchClause();\n    }\n\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n\n    if (!handler && !finalizer) {\n      throwError(Messages.NoCatchOrFinally);\n    }\n\n    return node.finishTryStatement(block, handler, finalizer);\n  } // ECMA-262 13.16 The debugger statement\n\n\n  function parseDebuggerStatement(node) {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return node.finishDebuggerStatement();\n  } // 13 Statements\n\n\n  function parseStatement() {\n    var type = lookahead.type,\n        expr,\n        labeledBody,\n        key,\n        node;\n\n    if (type === Token.EOF) {\n      throwUnexpectedToken(lookahead);\n    }\n\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n\n    isAssignmentTarget = isBindingElement = true;\n    node = new Node();\n\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return parseEmptyStatement(node);\n\n        case '(':\n          return parseExpressionStatement(node);\n\n        default:\n          break;\n      }\n    } else if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return parseBreakStatement(node);\n\n        case 'continue':\n          return parseContinueStatement(node);\n\n        case 'debugger':\n          return parseDebuggerStatement(node);\n\n        case 'do':\n          return parseDoWhileStatement(node);\n\n        case 'for':\n          return parseForStatement(node);\n\n        case 'function':\n          return parseFunctionDeclaration(node);\n\n        case 'if':\n          return parseIfStatement(node);\n\n        case 'return':\n          return parseReturnStatement(node);\n\n        case 'switch':\n          return parseSwitchStatement(node);\n\n        case 'throw':\n          return parseThrowStatement(node);\n\n        case 'try':\n          return parseTryStatement(node);\n\n        case 'var':\n          return parseVariableStatement(node);\n\n        case 'while':\n          return parseWhileStatement(node);\n\n        case 'with':\n          return parseWithStatement(node);\n\n        default:\n          break;\n      }\n    }\n\n    expr = parseExpression(); // ECMA-262 12.12 Labelled Statements\n\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.Redeclaration, 'Label', expr.name);\n      }\n\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return node.finishLabeledStatement(expr, labeledBody);\n    }\n\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  } // ECMA-262 14.1 Function Definition\n\n\n  function parseFunctionSourceElements() {\n    var statement,\n        body = [],\n        token,\n        directive,\n        firstRestricted,\n        oldLabelSet,\n        oldInIteration,\n        oldInSwitch,\n        oldInFunctionBody,\n        node = new Node();\n    expect('{');\n\n    while (startIndex < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n\n      token = lookahead;\n      statement = parseStatementListItem();\n      body.push(statement);\n\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      body.push(parseStatementListItem());\n    }\n\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return node.finishBlockStatement(body);\n  }\n\n  function validateParam(options, param, name) {\n    var key = '$' + name;\n\n    if (strict) {\n      if (isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    } else if (!options.firstRestricted) {\n      if (isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    }\n\n    options.paramSet[key] = true;\n  }\n\n  function parseParam(options) {\n    var token,\n        param,\n        params = [],\n        i,\n        def;\n    token = lookahead;\n\n    if (token.value === '...') {\n      param = parseRestElement(params);\n      validateParam(options, param.argument, param.argument.name);\n      options.params.push(param);\n      options.defaults.push(null);\n      return false;\n    }\n\n    param = parsePatternWithDefault(params);\n\n    for (i = 0; i < params.length; i++) {\n      validateParam(options, params[i], params[i].value);\n    }\n\n    if (param.type === Syntax.AssignmentPattern) {\n      def = param.right;\n      param = param.left;\n      ++options.defaultCount;\n    }\n\n    options.params.push(param);\n    options.defaults.push(def);\n    return !match(')');\n  }\n\n  function parseParams(firstRestricted) {\n    var options;\n    options = {\n      params: [],\n      defaultCount: 0,\n      defaults: [],\n      firstRestricted: firstRestricted\n    };\n    expect('(');\n\n    if (!match(')')) {\n      options.paramSet = {};\n\n      while (startIndex < length) {\n        if (!parseParam(options)) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n\n    if (options.defaultCount === 0) {\n      options.defaults = [];\n    }\n\n    return {\n      params: options.params,\n      defaults: options.defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n\n  function parseFunctionDeclaration(node, identifierIsOptional) {\n    var id = null,\n        params = [],\n        defaults = [],\n        body,\n        token,\n        stricted,\n        tmp,\n        firstRestricted,\n        message,\n        previousStrict,\n        isGenerator,\n        previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n\n    if (isGenerator) {\n      lex();\n    }\n\n    if (!identifierIsOptional || !match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    state.allowYield = !isGenerator;\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n  }\n\n  function parseFunctionExpression() {\n    var token,\n        id = null,\n        stricted,\n        firstRestricted,\n        message,\n        tmp,\n        params = [],\n        defaults = [],\n        body,\n        previousStrict,\n        node = new Node(),\n        isGenerator,\n        previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n\n    if (isGenerator) {\n      lex();\n    }\n\n    state.allowYield = !isGenerator;\n\n    if (!match('(')) {\n      token = lookahead;\n      id = !strict && !isGenerator && matchKeyword('yield') ? parseNonComputedProperty() : parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n  } // ECMA-262 14.5 Class Definitions\n\n\n  function parseClassBody() {\n    var classBody,\n        token,\n        isStatic,\n        hasConstructor = false,\n        body,\n        method,\n        computed,\n        key;\n    classBody = new Node();\n    expect('{');\n    body = [];\n\n    while (!match('}')) {\n      if (match(';')) {\n        lex();\n      } else {\n        method = new Node();\n        token = lookahead;\n        isStatic = false;\n        computed = match('[');\n\n        if (match('*')) {\n          lex();\n        } else {\n          key = parseObjectPropertyKey();\n\n          if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n            token = lookahead;\n            isStatic = true;\n            computed = match('[');\n\n            if (match('*')) {\n              lex();\n            } else {\n              key = parseObjectPropertyKey();\n            }\n          }\n        }\n\n        method = tryParseMethodDefinition(token, key, computed, method);\n\n        if (method) {\n          method['static'] = isStatic; // jscs:ignore requireDotNotation\n\n          if (method.kind === 'init') {\n            method.kind = 'method';\n          }\n\n          if (!isStatic) {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n              if (method.kind !== 'method' || !method.method || method.value.generator) {\n                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n              }\n\n              if (hasConstructor) {\n                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n              } else {\n                hasConstructor = true;\n              }\n\n              method.kind = 'constructor';\n            }\n          } else {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n              throwUnexpectedToken(token, Messages.StaticPrototype);\n            }\n          }\n\n          method.type = Syntax.MethodDefinition;\n          delete method.method;\n          delete method.shorthand;\n          body.push(method);\n        } else {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n\n    lex();\n    return classBody.finishClassBody(body);\n  }\n\n  function parseClassDeclaration(identifierIsOptional) {\n    var id = null,\n        superClass = null,\n        classNode = new Node(),\n        classBody,\n        previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n\n    if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassDeclaration(id, superClass, classBody);\n  }\n\n  function parseClassExpression() {\n    var id = null,\n        superClass = null,\n        classNode = new Node(),\n        classBody,\n        previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n\n    if (lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassExpression(id, superClass, classBody);\n  } // ECMA-262 15.2 Modules\n\n\n  function parseModuleSpecifier() {\n    var node = new Node();\n\n    if (lookahead.type !== Token.StringLiteral) {\n      throwError(Messages.InvalidModuleSpecifier);\n    }\n\n    return node.finishLiteral(lex());\n  } // ECMA-262 15.2.3 Exports\n\n\n  function parseExportSpecifier() {\n    var exported,\n        local,\n        node = new Node(),\n        def;\n\n    if (matchKeyword('default')) {\n      // export {default} from 'something';\n      def = new Node();\n      lex();\n      local = def.finishIdentifier('default');\n    } else {\n      local = parseVariableIdentifier();\n    }\n\n    if (matchContextualKeyword('as')) {\n      lex();\n      exported = parseNonComputedProperty();\n    }\n\n    return node.finishExportSpecifier(local, exported);\n  }\n\n  function parseExportNamedDeclaration(node) {\n    var declaration = null,\n        isExportFromIdentifier,\n        src = null,\n        specifiers = []; // non-default export\n\n    if (lookahead.type === Token.Keyword) {\n      // covers:\n      // export var f = 1;\n      switch (lookahead.value) {\n        case 'let':\n        case 'const':\n          declaration = parseLexicalDeclaration({\n            inFor: false\n          });\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n\n        case 'var':\n        case 'class':\n        case 'function':\n          declaration = parseStatementListItem();\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n      }\n    }\n\n    expect('{');\n\n    while (!match('}')) {\n      isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n      specifiers.push(parseExportSpecifier());\n\n      if (!match('}')) {\n        expect(',');\n\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n\n    expect('}');\n\n    if (matchContextualKeyword('from')) {\n      // covering:\n      // export {default} from 'foo';\n      // export {foo} from 'foo';\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n    } else if (isExportFromIdentifier) {\n      // covering:\n      // export {default}; // missing fromClause\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    } else {\n      // cover\n      // export {foo};\n      consumeSemicolon();\n    }\n\n    return node.finishExportNamedDeclaration(declaration, specifiers, src);\n  }\n\n  function parseExportDefaultDeclaration(node) {\n    var declaration = null,\n        expression = null; // covers:\n    // export default ...\n\n    expectKeyword('default');\n\n    if (matchKeyword('function')) {\n      // covers:\n      // export default function foo () {}\n      // export default function () {}\n      declaration = parseFunctionDeclaration(new Node(), true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n\n    if (matchKeyword('class')) {\n      declaration = parseClassDeclaration(true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n\n    if (matchContextualKeyword('from')) {\n      throwError(Messages.UnexpectedToken, lookahead.value);\n    } // covers:\n    // export default {};\n    // export default [];\n    // export default (1 + 2);\n\n\n    if (match('{')) {\n      expression = parseObjectInitializer();\n    } else if (match('[')) {\n      expression = parseArrayInitializer();\n    } else {\n      expression = parseAssignmentExpression();\n    }\n\n    consumeSemicolon();\n    return node.finishExportDefaultDeclaration(expression);\n  }\n\n  function parseExportAllDeclaration(node) {\n    var src; // covers:\n    // export * from 'foo';\n\n    expect('*');\n\n    if (!matchContextualKeyword('from')) {\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return node.finishExportAllDeclaration(src);\n  }\n\n  function parseExportDeclaration() {\n    var node = new Node();\n\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalExportDeclaration);\n    }\n\n    expectKeyword('export');\n\n    if (matchKeyword('default')) {\n      return parseExportDefaultDeclaration(node);\n    }\n\n    if (match('*')) {\n      return parseExportAllDeclaration(node);\n    }\n\n    return parseExportNamedDeclaration(node);\n  } // ECMA-262 15.2.2 Imports\n\n\n  function parseImportSpecifier() {\n    // import {<foo as bar>} ...;\n    var local,\n        imported,\n        node = new Node();\n    imported = parseNonComputedProperty();\n\n    if (matchContextualKeyword('as')) {\n      lex();\n      local = parseVariableIdentifier();\n    }\n\n    return node.finishImportSpecifier(local, imported);\n  }\n\n  function parseNamedImports() {\n    var specifiers = []; // {foo, bar as bas}\n\n    expect('{');\n\n    while (!match('}')) {\n      specifiers.push(parseImportSpecifier());\n\n      if (!match('}')) {\n        expect(',');\n\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n\n    expect('}');\n    return specifiers;\n  }\n\n  function parseImportDefaultSpecifier() {\n    // import <foo> ...;\n    var local,\n        node = new Node();\n    local = parseNonComputedProperty();\n    return node.finishImportDefaultSpecifier(local);\n  }\n\n  function parseImportNamespaceSpecifier() {\n    // import <* as foo> ...;\n    var local,\n        node = new Node();\n    expect('*');\n\n    if (!matchContextualKeyword('as')) {\n      throwError(Messages.NoAsAfterImportNamespace);\n    }\n\n    lex();\n    local = parseNonComputedProperty();\n    return node.finishImportNamespaceSpecifier(local);\n  }\n\n  function parseImportDeclaration() {\n    var specifiers = [],\n        src,\n        node = new Node();\n\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalImportDeclaration);\n    }\n\n    expectKeyword('import');\n\n    if (lookahead.type === Token.StringLiteral) {\n      // import 'foo';\n      src = parseModuleSpecifier();\n    } else {\n      if (match('{')) {\n        // import {bar}\n        specifiers = specifiers.concat(parseNamedImports());\n      } else if (match('*')) {\n        // import * as foo\n        specifiers.push(parseImportNamespaceSpecifier());\n      } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {\n        // import foo\n        specifiers.push(parseImportDefaultSpecifier());\n\n        if (match(',')) {\n          lex();\n\n          if (match('*')) {\n            // import foo, * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n          } else if (match('{')) {\n            // import foo, {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n          } else {\n            throwUnexpectedToken(lookahead);\n          }\n        }\n      } else {\n        throwUnexpectedToken(lex());\n      }\n\n      if (!matchContextualKeyword('from')) {\n        throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n      }\n\n      lex();\n      src = parseModuleSpecifier();\n    }\n\n    consumeSemicolon();\n    return node.finishImportDeclaration(specifiers, src);\n  } // ECMA-262 15.1 Scripts\n\n\n  function parseScriptBody() {\n    var statement,\n        body = [],\n        token,\n        directive,\n        firstRestricted;\n\n    while (startIndex < length) {\n      token = lookahead;\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      statement = parseStatementListItem();\n      body.push(statement);\n\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    while (startIndex < length) {\n      statement = parseStatementListItem();\n      /* istanbul ignore if */\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      body.push(statement);\n    }\n\n    return body;\n  }\n\n  function parseProgram() {\n    var body, node;\n    peek();\n    node = new Node();\n    body = parseScriptBody();\n    return node.finishProgram(body, state.sourceType);\n  }\n\n  function filterTokenLocation() {\n    var i,\n        entry,\n        token,\n        tokens = [];\n\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (entry.regex) {\n        token.regex = {\n          pattern: entry.regex.pattern,\n          flags: entry.regex.flags\n        };\n      }\n\n      if (extra.range) {\n        token.range = entry.range;\n      }\n\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n\n      tokens.push(token);\n    }\n\n    extra.tokens = tokens;\n  }\n\n  function tokenize(code, options, delegate) {\n    var toString, tokens;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: []\n    };\n    extra = {}; // Options matching.\n\n    options = options || {}; // Of course we collect tokens here.\n\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenValues = [];\n    extra.tokenize = true;\n    extra.delegate = delegate; // The following two fields are necessary to compute the Regex tokens.\n\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n\n    try {\n      peek();\n\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n\n      lex();\n\n      while (lookahead.type !== Token.EOF) {\n        try {\n          lex();\n        } catch (lexError) {\n          if (extra.errors) {\n            recordError(lexError); // We have to break on the first error\n            // to avoid infinite loops.\n\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n\n      tokens = extra.tokens;\n\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return tokens;\n  }\n\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: [],\n      sourceType: 'script'\n    };\n    strict = false;\n    extra = {};\n\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n\n      if (options.sourceType === 'module') {\n        // very restrictive condition for now\n        state.sourceType = options.sourceType;\n        strict = true;\n      }\n    }\n\n    try {\n      program = parseProgram();\n\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return program;\n  } // Sync with *.json manifests.\n\n\n  exports.version = '2.7.3';\n  exports.tokenize = tokenize;\n  exports.parse = parse; // Deep copy.\n\n  /* istanbul ignore next */\n\n  exports.Syntax = function () {\n    var name,\n        types = {};\n\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":null,"metadata":{},"sourceType":"script"}